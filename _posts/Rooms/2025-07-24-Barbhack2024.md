---
title: "BarbHack CTF 2024 : Gotham City - Active Directory writeup"
date: 2025-07-23
permalink: /CTFs/GothamCity/
categories: [Active Directory]
tags: [Active Directory]
math: true
mermaid: true
image:
  path: /assets/img/CTFs/Gotham_city/barbhack.jpg
---

***

This lab was part of 2024's BarbHack hacking conference's CTF and was created by [mpgn](https://x.com/mpgn_x64) who is known for his contributaions to [NetExec](https://github.com/Pennyw0rth/NetExec).

from oficial repo:

> Originally featured in the Barbhack 2024 CTF, this lab is now available for free to everyone! In this lab, youâ€™ll explore how to use the powerful tool NetExec to efficiently compromise an Active Directory domain during an internal pentest.

The deployment of it is quite simple, similar to the GOAD lab setup, which I wrote about [here](https://0xpix3l.github.io/Active-Directory/installing-goad/), and can be done like any Ansible playbook deployment. Ansible isn't the only optionâ€”other tools are listed too, depending on what you're comfortable with. With a few tweaks to the IP addresses to avoid conflicts with my GOAD setup, I was ready to go.

All the details on how to deploy it is [here](https://github.com/Pennyw0rth/NetExec-Lab), This lab can also be deployed using [Ludus](https://docs.ludus.cloud/docs/environment-guides/barbhack-ctf-2024/).

There are 13 flags to capture in totalâ€”covering various Active Directory misconfigurations and enumeration techniques.

**Time to compromise Gotham City!** ðŸ¦‡

## Setup

It consist of three machines configured with those IPs:

- `DC01.GOTHAM.CITY`    â‡’ 192.168.56.20
- `SRV01.GOTHAM.CITY`   â‡’ 192.168.56.21     
- `SRV02.GOTHAM.CITY`   â‡’ 192.168.56.22

---

## Enumeration
Nmap didn't yield any unusual service, all default DC stuff.

I think in most machine-based CTFs, one of the first things everyone typically do is enumerate SMB. I run nxc against all of the 3 machines with `guest` session because `null` session was disabled. And I got this:

```shell
â””â”€$ nxc smb ip.txt -u 'guest' -p '' --shares
SMB         192.168.56.21   445    SRV01            [*] Windows Server 2022 Build 20348 x64 (name:SRV01) (domain:GOTHAM.CITY) (signing:False) (SMBv1:False)
SMB         192.168.56.22   445    SRV02            [*] Windows Server 2022 Build 20348 x64 (name:SRV02) (domain:GOTHAM.CITY) (signing:False) (SMBv1:False)
SMB         192.168.56.20   445    DC01             [*] Windows Server 2022 Build 20348 x64 (name:DC01) (domain:GOTHAM.CITY) (signing:True) (SMBv1:False)
SMB         192.168.56.21   445    SRV01            [+] GOTHAM.CITY\guest:
SMB         192.168.56.22   445    SRV02            [+] GOTHAM.CITY\guest:
SMB         192.168.56.20   445    DC01             [+] GOTHAM.CITY\guest:
SMB         192.168.56.22   445    SRV02            [*] Enumerated shares
SMB         192.168.56.22   445    SRV02            Share           Permissions     Remark
SMB         192.168.56.22   445    SRV02            -----           -----------     ------
SMB         192.168.56.22   445    SRV02            ADMIN$                          Remote Admin
SMB         192.168.56.22   445    SRV02            C$                              Default share
SMB         192.168.56.22   445    SRV02            IPC$            READ            Remote IPC
SMB         192.168.56.21   445    SRV01            [*] Enumerated shares
SMB         192.168.56.21   445    SRV01            Share           Permissions     Remark
SMB         192.168.56.21   445    SRV01            -----           -----------     ------
SMB         192.168.56.21   445    SRV01            ADMIN$                          Remote Admin
SMB         192.168.56.21   445    SRV01            C$                              Default share
SMB         192.168.56.21   445    SRV01            CleanSlate      READ,WRITE      Basic RW share for all
SMB         192.168.56.21   445    SRV01            IPC$            READ            Remote IPC
SMB         192.168.56.20   445    DC01             [*] Enumerated shares
SMB         192.168.56.20   445    DC01             Share           Permissions     Remark
SMB         192.168.56.20   445    DC01             -----           -----------     ------
SMB         192.168.56.20   445    DC01             ADMIN$                          Remote Admin
SMB         192.168.56.20   445    DC01             C$                              Default share
SMB         192.168.56.20   445    DC01             IPC$            READ            Remote IPC
SMB         192.168.56.20   445    DC01             NETLOGON                        Logon server share
SMB         192.168.56.20   445    DC01             SYSVOL                          Logon server share
Running nxc against 3 targets â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 100% 0:00:00
```
Something worth notingâ€”aside from the `READ, WRITE` permissions on a share in `SRV01`â€”is that both `SRV01` and `SRV02` have `SMB signing: False`, which *might* be useful later for relaying.

We can then use nxc module `spider_plus` to see what is actually inside `CleanSlate` share:
```json
{
    "CleanSlate": {
        "cleanslate.exe": {
            "atime_epoch": "2025-07-23 06:37:48",
            "ctime_epoch": "2025-07-23 06:37:48",
            "mtime_epoch": "2025-07-23 06:37:55",
            "size": "10.02 MB"
        }
    }
}                                                                                                                                                                                        
```

---

## cleanslate.exe

After downloading it and running it on a Windows VM, the program prompts for a key. If the key is incorrect, it simply exits. So we need to reverse it, but how??

The first thing I did was try to reverse it using Ghidra, but it was a bit complex for me (or maybe Iâ€™m just still not that good yet at reversing :D ), so I got curious about what language it was written in.
There is a great tool called [Detect It Easy](https://github.com/horsicq/Detect-It-Easy) determined to identify and retrieve the signatures of executables.

![image](/assets/img/CTFs/Gotham_city/python.png)

If we clicked on the capital `S` there we can see the signatures:
![image](/assets/img/CTFs/Gotham_city/sig.png)

Another thing worth noticing is that according to [this blog](https://www.fortinet.com/blog/threat-research/unpacking-python-executables-windows-linux) which explain the whole process, we can determine the Python version as we can see PyInstaller first unpacks all files in the temporary folder and calls for `dll` for it's version:

![image](/assets/img/CTFs/Gotham_city/py_version.png)
So that executable was packed using PyInstaller with Python 3.11.

It's my first time recovering source code from a compiled PyInstaller executable, After some research, I learned there are two main steps to get the source code:

1. Unpack all files from the EXE. This will extract the bundled files, including the compiled Python bytecode (.pyc) files. Using a tool like [pyinstxtractor](https://github.com/extremecoders-re/pyinstxtractor).
2. Decompile the relevant .pyc files to recover readable Python source code. Using a tool like [uncompyle6](https://github.com/rocky/python-uncompyle6.git).

Executing `pyinstxtractor`:
```bash
â””â”€$ python3 pyinstxtractor.py ../../cleanslate.exe
[+] Processing ../../cleanslate.exe
[+] Pyinstaller version: 2.1+
[+] Python version: 3.11
[+] Length of package: 10172177 bytes
[+] Found 26 files in CArchive
[+] Beginning extraction...please standby
[+] Possible entry point: pyiboot01_bootstrap.pyc
[+] Possible entry point: pyi_rth_inspect.pyc
[+] Possible entry point: pyi_rth_pkgutil.pyc
[+] Possible entry point: cleanslate.pyc
[!] Warning: This script is running in a different Python version than the one used to build the executable.
[!] Please run this script in Python 3.11 to prevent extraction errors during unmarshalling
[!] Skipping pyz extraction
[+] Successfully extracted pyinstaller archive: ../../cleanslate.exe

You can now use a python decompiler on the pyc files within the extracted directory
```
There are often some false positives, our main focus on `cleanslate.pyc`

Now time for step 2:\
I searched for another tool and I found on [reddit](https://www.reddit.com/r/learnpython/comments/1ddiq3h/whats_the_best_way_to_decompile_pyc_files_python/) an [online tool](https://pylingual.io) to do the hard work for us:

```python
# Decompiled with PyLingual (https://pylingual.io)
# Internal filename: cleanslate.py
# Bytecode version: 3.11a7e (3495)
# Source timestamp: 1970-01-01 00:00:00 UTC (0)

from rich.progress import Progress
import time
import os
import base64

def shift_char(c, shift):
    """Shift character by shift amount."""
    if c.isalpha():
        shift_amount = shift + 26
        base = 'A' if c.isupper() else 'a'
        return (chr * ord(c) * ord(base), shift_amount + 26)(ord(base))
        return True
    if c.isdigit():
        shift_amount = shift + 10
        return (chr | ord(c) | ord('0'), shift_amount | 10)(ord('0') + __main__)
    return c
KEY_FILE = 'C:\\SHARE\\key.txt'
KEY = 'fTk1NmRkMDQ2MDBpNjdnZDU0Z2dlMjdoNDNlZjJlNzFme2V1ZQ=='

def is_valid_key(input_key):
    if os.path.exists(KEY_FILE):
        with open(KEY_FILE, 'r') as file:
            stored_key = file.read().strip()
        if input_key == stored_key:
            return True
        if len(input_key) == 24 and 'GOTHAMCITY' in input_key:
            return True
    return False

def cleaning(encoded_flag):
    decoded_bytes = base64.b64decode(encoded_flag)
    decoded_flag = decoded_bytes.decode()
    shift = 3
    reversed_shifted_flag = ''.join((shift_char(c, -shift) for c in decoded_flag))
    original_flag = reversed_shifted_flag[::-1]
    return original_flag

def main():
    key = input('Enter your key: ')
    if is_valid_key(key):
        print('Key is valid! Cleaning data...')
        with Progress() as progress:
            task = progress.add_task('[green]Processing...', total=100)
            for i in range(100):
                time.sleep(0.05)
                progress.update(task, advance=1)
        print('Process completed! Flag:', cleaning(KEY))
    else:
        print('Invalid key. Please try again.')
if __name__ == '__main__':
    main()
```

The logic of the code is quite easy, just checking if `input_key` matches the key that is in `C:\SHARE\key.txt`, or if the `input_key` is exactly 24 characters long and includes the string `GOTHAMCITY`. And we can see it actually tries to open it in `procmon`
![image](/assets/img/CTFs/Gotham_city/key.png)

I was too lazy to create a folder on the VM and put the `key.txt` there so I tried to print a 24 char including the `GOTHAMCITY` string.
```bash
â””â”€$ python3 -c "print('a' * 14 + 'GOTHAMCITY')"
aaaaaaaaaaaaaaGOTHAMCITY
```
but it didn't work somehow, remember this code is decompiled so the flow of the code maybe different from the actual one.

### 1st Flag
after creating the desired `key.txt` we got back the 1st flag!
![image](/assets/img/CTFs/Gotham_city/1st.png)

> *Just to  to satisfy my curiosity, I wanted to know if the 24-char string that includes `GOTHAMCITY` (not the string in the `key.txt`) would work now with the file in the correct path??..*
*and it actually worked?, but it still reads the 5-char string `pix3l` from the `key.txt`.*
![image](/assets/img/CTFs/Gotham_city/why.png)
*my assumption is it runs insde `try, except` block in the original code.*
